INSTRUCTION FLAGS
je  ZF=1                    Jump if	equal              Signed,	unsigned
jne ZF=0                    Jump if	not	equal          Signed,	unsigned
jg  ((SF XOR OF) OR ZF)	= 0 Jump if	greater            Signed
jge (SF	XOR	OF)	= 0         Jump if	greater	or equal   Signed
jl  (SF	XOR	OF)	=	1       Jump if lower              Signed
jle ((SF XOR OF) OR	ZF)	= 1 Jump if	lower or equal     Signed
ja  (CF OR ZF) = 0          Jump if	above Unsigned
jae CF=0                    Jump if above or equal     Unsigned
jb  CF=1                    Jump if lesser             Unsigned
jbe (CF	OR	ZF)	=	1       Jump if lesser or equal    Unsigned

CALLING CONVENTION
; 1st arg           Stack           EBX               RDI            RDI
; 2nd arg           Stack           ECX               RSI            RSI
; 3rd arg           Stack           EDX               RDX            RDX
; 4th arg           Stack           ESI               RCX            R10
; 5th arg           Stack           EDI               R8             R8
; 6th arg           Stack           EBP               R9

MOVS
;If the direction flag is cleared (DF = 0), the RSI register is incremented after each string operation.
;If the direction flag is set (DF = 1), the RSI register is decremented after each string operation.

HIGHER PART CLEARING
;Copying a value in an 8-bit or 16-bit register does not clear the higher part
;of a 64-bit register.
;However, copying a value in a 32-bit register does clear the higher part of a
;64-bit register.

INT NEGATIVES
You obtain the binary representation of a negative number as follows:
1. Write the binary of the absolute value.
2. Take the complement (change all the 1s to 0s and the 0s to 1s).
3. Add 1.

READELF
readelf --file-header ./memory.out
readelf --symbols ./memory.out | grep start
readelf --symbols ./memory.out |tail +10|sort -k 2 -r ; sorts 2nd column in rev


Check if we are on a 32-bit or 64-bit system
mov eax, 0x01         ; sysinfo call number
xor edi, edi          ; clear EDI register
xor edx, edx          ; clear EDX register
int 0x80              ; make syscall

test edi, edi          ; Check the architecture
jz .32_bit             ; If zero (32-bit), jump to .32_bit


There are sixteen 64-bit registers in x86-64: %rax, %rbx, %rcx, %rdx, %rdi, %rsi, %rbp,
%rsp, and %r8-r15.
Of these, %rax, %rcx, %rdx, %rdi, %rsi, %rsp, and %r8-r11 are considered caller-save registers,
meaning that they are not necessarily saved across function calls.
By convention, %rax is used to store a functionâ€™s return value, if it exists and is no more
than 64 bits long. (Larger return types like structs are returned using the stack.)
Registers %rbx, %rbp, and %r12-r15 are callee-save registers, meaning that they are saved across function
calls.
Register %rsp is used as the stack pointer, a pointer to the topmost element in the stack.
Additionally, %rdi, %rsi, %rdx, %rcx, %r8, and %r9 are used to pass the first six integer
or pointer parameters to called functions. Additional parameters (or large parameters such as
structs passed by value) are passed on the stack.